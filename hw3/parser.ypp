%{
	#include <iostream>
	#include <cstdlib>
	#include "hw3_output.hpp"
	#include "types.hpp"
	#include "utils.cpp"
	TableManager manager;
	extern int yylex();
	extern int yylineno;
	extern int yyleng;
	extern char* yytext;
	int yyerror(const char * message);
%}


%right IF
%right ELSE

%token VOID
%token INT
%token BYTE
%token B
%token BOOL
%token TRUE
%token FALSE
%token RETURN
%token WHILE
%token BREAK
%token CONTINUE
%token SC
%token COMMA
%token ASSIGN
%token RELOP
%token ID
%token NUM
%token STRING
%type <FormalsList> Formals FormalsList
%type <ExpList> ExpList
%type <Func> FuncsDecl

%left OR
%left AND
%left RELOP
%left ADD
%left MULT
%left NOT
%right LBRACE RBRACE LPAREN RPAREN

%%

Program 	: Funcs		{output::printProductionRule(1);}
;
Funcs		: /*epsilon*/		{output::printProductionRule(2);}
			| FuncsDecl Funcs	{output::printProductionRule(3);}
;
FuncsDecl 	: RetType ID LPAREN Formals RPAREN LBRACE    #some issues to solve scoping, legality of insertion, insertion of symbols in order
			{ /* this marker is $7 */
			    $$.params = $4.list;
			    $$.ret_type = $1.type;
			    $$.name = $2.name;
			    $$.type = "func";
                manager.insert($$)
			} Statements RBRACE 	
{

	output::endScope();manager.popScope();

}
;
RetType 	: Type	{$$.type = $$.name = $1.type;}
			| VOID  {$$.type = "void"}
;
Formals 	: /*epsilon*/ {}
			| FormalsList {$$.list = $1.list;}
;
FormalsList : FormalDecl {$$.list.push_back(YYSTYPE($1));}
			| FormalDecl COMMA FormalsList { $$.list.push_back($1); $$.list += $3.list;}
;
FormalDecl 	: Type ID {if(manager.contains($2.name)){output::errorDef();}$$.type = $1.type; $$.name = $2.name;}
;
Statements 	: Statement
		   	| Statements Statement
;
Statement 	: LBRACE {manager.newScope();} Statements RBRACE {output::endScope();manager.popScope();}

			| Type ID SC 			{ /* insert new symbol */
										if (manager.contains($2.name))
											output::errorDef(yylineno, $2.name);
										else
											manager.insertID(YYSTYPE($2.name, $1.type));
									}
			| Type ID ASSIGN Exp SC { /* insert a symbol, maybe cast */
										if (!($1.type == $4.type))
											output::errorMismatch(yylineno);
										/*todo*/
									}
			| ID ASSIGN Exp SC  	{ /* maybe cast */
										YYSTYPE& y = *(manager.get($1.name));
										
										if (!legalImplicitCast(y.type, $3.type) || (y.type == $3.type))
										{
											output::errorMismatch(yylineno);
										}
										
									}
			| RETURN Exp SC			{ /* check NOT void ret type */
										if (!manager.legalReturn($2.type)
										{
											/* error return mismatch*/
											output::errorMismatch(yylineno);
										}
									}
			| IF LPAREN Exp RPAREN {manager.newScope("if");} Statement {output::endScope();manager.popScope();} %prec IF
			| IF LPAREN Exp RPAREN {manager.newScope("if");} Statement {output::endScope();manager.popScope();} ELSE {manager.newScope("else");}Statement {output::endScope();manager.popScope();}
			| WHILE LPAREN Exp RPAREN {manager.newScope("while");} Statement {output::endScope();manager.popScope();}

			| BREAK SC  	{ 
								if (!manager.inScope("while"))
								    output::errorUnexpectedBreak(yylineno);
							}
			| CONTINUE SC   {
								if (!manager.inScope("while"))
									output::errorUnexpectedContinue(yylineno);
							}
;
Call 		: ID LPAREN ExpList RPAREN		{
												Func& func = dynamic_cast<Func> *(manager.get($1.name));
												if (!func.legalParams($3)){
													output::errorPrototypeMismatch();
													
												}
												$$.type = func.ret_type;
												
											}
	 		| ID LPAREN RPAREN				{}
;
ExpList 	: Exp	{$$.list.push_back($1)}
			| Exp COMMA ExpList		{$$.list.push_back($1);$$list += $3.list;}
;
Type 		: INT	{ $$.type = "INT";}
			| BYTE	{ $$.type = "BYTE";}
			| BOOL	{ $$.type = "BOOL";}
;
Exp 		: LPAREN Exp RPAREN	{$$.type = $2.type;}                  #TYPES HAVE TO BE CAPITILIZED LIKE RULES GIVEN IN HW3 PDF
			| Exp IF LPAREN Exp RPAREN ELSE Exp {
													checkBoolean($4);
													if (isNumeral($1) && isNumeral($7))
													{
														$$.type = largestType($1.type, $7.type);
													}
													else if ($1.type != $7.type)
													{
														output::errorMismatch(yylineno);
													}
													else
													{
														$$.type = $1.type;
													}
												}
			| Exp ADD Exp 	{
								checkNumeral($1);
								checkNumeral($3);
								$$.type = largestType($1.type, $3.type);
							}
			| Exp MULT Exp	{	
								checkNumeral($1);
								checkNumeral($3);
								$$.type = largestType($1.type, $3.type);
							}
			| ID 	{
						YYSTYPE* y = manager.get($1.name);
						$$.type = y->type;

					}
			| Call	{$$.type = $1.type;}
			| NUM	{$$.type = "INT";}
			| NUM B {$$.type = "BYTE";}
			| STRING	{$$.type = "STRING";}
			| TRUE		{$$.type = "BOOL";}
			| FALSE		{$$.type = "BOOL";}
			| NOT Exp	{
							checkBoolean($2);
							$$.type = "BOOL";
						}
			| Exp AND Exp	{
								checkBoolean($1);
								checkBoolean($3);
								$$.type == "BOOL";
							}
			| Exp OR Exp	{
								checkBoolean($1);
								checkBoolean($3);
								$$.type == "BOOL";
							}
			| Exp RELOP Exp	{
								checkNumeral($1);
								checkNumeral($3);
								$$.type == "BOOL";
							}
			| LPAREN Type RPAREN Exp	{
											YYSTYPE y;
											$$.value = $4.value;
											$$.type = $2.type;
											checkByteAndValue($$);
										}
;

%%
int main()
{
	return yyparse();
}

int yyerror(const char * message)
{
	output::errorSyn(yylineno);
	exit(1);
}

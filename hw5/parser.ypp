%{
	#include <iostream>
	#include <cstdlib>
	#include <memory>
	#include "bp.hpp"
	#include "hw3_output.hpp"
	#include "types.hpp"
	#include "utils.hpp"

	TableManager manager;
	CodeBuffer& buffer = CodeBuffer::instance();
	bool inPrintArgs = false;
	extern int yylex();
	extern int yylineno;
	extern int yyleng;
	extern char* yytext;
	int yyerror(const char * message);
	/*
	int x = 5; // t1 = x

	x = 3; // t2 = x

	int y = x + 8; // t3 = t2 + 8

	x = 8; // t4 = 8 

	y = x + 2 + 1; // t5 = t4 + 9 
	t10 = 9 + 5;
	t11 = x + t10;
	*/

%}


%right IF
%right ELSE

%token VOID
%token INT
%token BYTE
%token B
%token BOOL
%token TRUE
%token FALSE
%token RETURN
%token WHILE
%token BREAK
%token CONTINUE
%token SC
%token COMMA
%token ASSIGN
%token RELOP
%token <id> ID
%token NUM
%token STRING
%type <funcid> FuncID;
%type <FormalsList> Formals FormalsList
%type <ExpList> ExpList
%type <Func> FuncsDecl
%type <TYPE> Exp Type Call FormalDecl RetType BoolExp Statement Statements freshLabelMarker

%left OR
%left AND
%left RELOP
%left ADD SUB
%left MULT DIV
%left NOT
%right LBRACE RBRACE LPAREN RPAREN

%%

Program 	: Funcs		{}
;
Funcs		: /*epsilon*/		{}
			| FuncsDecl Funcs	{}
;
FuncsDecl 	: RetType FuncID LPAREN Formals
			{
				if (manager.get($2) != nullptr)
				{
					output::errorDef(yylineno, $2);
					exit(1);
				}
				FuncClass* func = new FuncClass();
				func->name = $2;
			    func->type = $1.type;
				func->params = $4.list;
				func->ret_type = $1.type;
				if (manager.contains($2))
				{
					output::errorDef(yylineno, $2);
					exit(1);
				}
                manager.insert(func);
				manager.newScope("func", func->ret_type);
				manager.insertParams($4.list);

			} RPAREN LBRACE Statements RBRACE 	
{
	FuncClass *func = dynamic_cast<FuncClass*>(manager.get($2));
	if (func == nullptr)
	{
		printf("bad pointer");
		exit(1);
	}

	///*output::endScope*/();
	manager.popScope();

}
;
RetType 	: Type	{$$.type = $$.name = $1.type;}
			| VOID  {$$.type = "VOID";}
;
Formals 	: /*epsilon*/ {}
			| FormalsList 	{
								$$.list = $1.list;

							}
;
FormalsList : FormalDecl {$$.list.push_back(TYPEClass($1));}
			| FormalDecl COMMA FormalsList { $$.list.push_back($1); $$.list.insert( $$.list.end(), $3.list.begin(), $3.list.end() );}
;
FormalDecl 	: Type ID 	{
							if(manager.contains(yylval.id))
							{
								output::errorDef(yylineno, yylval.id);
								exit(1);
							}
							$$.type = $1.type;
							$$.name = yylval.id;
						}
;
NEWSCOPE : {manager.newScope("if");};
ENDSCOPE : {/*output::endScope();*/manager.popScope();}
BoolExp : Exp {checkBoolean($1); $$.truelist = $1.truelist; $$.falselist = $1.falselist; $$.label = $1.label;}
Statements 	: freshLabelMarker Statement {$$.label = $1.label;}
		   	| Statements Statement { $$.label = $1.label;}
;
freshLabelMarker : {$$.label = freshLabel("statements"); buffer.emit($$.label + ":");}
Statement 	: LBRACE {manager.newScope("regular");} Statements RBRACE {$$.label = $3.label; /*output::endScope();*/manager.popScope(); }

			| Type ID SC 			{ 
										/* insert new symbol */
										if (manager.contains(yylval.id))
										{
											output::errorDef(yylineno, yylval.id);
											exit(1);
										}
										else
										{
										    /*
										    %ptr = alloca i32
										    store i32 <default value>, ptr %ptr
										    */
											TYPEClass* y = new TYPEClass(yylval.id, $1.type);
											y->reg = freshVar();
											manager.insertID(y);
											buffer.emit(y->reg + " = add " + getSizeByType(y->type) + " " + initialize(y->type) + ", 0");
										}

									}
			| Type ID { $2 = std::string(yylval.id);} ASSIGN Exp SC { 
										/* insert a symbol, maybe cast */
										if (manager.contains($2))
										{
											output::errorDef(yylineno, $2);
											exit(1);
										}
										if (!legalAssign($5.type, $1.type))
										{
											output::errorMismatch(yylineno);
											exit(1);
										}
										else
										{
											/*
                                            %ptr = alloca i32
                                            store i32 Exp.reg, ptr %ptr
                                            */
											TYPEClass* y = new TYPEClass($2, $1.type);
											y->reg = freshVar();
											manager.insertID(y);
											if (y->type != "BOOL") buffer.emit(y->reg + " = add " + getSizeByType(y->type) + " " + $5.reg + ", 0");
										}
										
										/*todo*/
									}
			| ID {$1 = yylval.id;} ASSIGN Exp SC  	{ 
										/* maybe cast */
										TYPEClass* y = manager.get($1);

										if (y == nullptr)
										{
											output::errorUndef(yylineno, $1);
											exit(1);
										}

										FuncClass* func_y = dynamic_cast<FuncClass*>(y);
										if (func_y != nullptr)
										{
											output::errorUndef(yylineno, func_y->name);
											exit(1);
										}
										if (!legalAssign($4.type, y->type))
										{
											output::errorMismatch(yylineno);
											exit(1);
										}
										/*
										store i32 Exp.reg, ptr ID.ptr
										*/
										y->reg = freshVar();
										if (y->type != "BOOL") buffer.emit(y->reg + " = add " + getSizeByType(y->type) + " " + $4.reg + ", 0");
									}
			| Call SC				{									
									}
			| RETURN SC				{	
										/* check void ret type */
										if (!manager.legalReturn("VOID"))
										{
											/* error return mismatch*/
											output::errorMismatch(yylineno);
											exit(1);
										}

									}
			| RETURN Exp SC			{ /* check NOT void ret type */

										
										if (!manager.legalReturn($2.type) || $2.type == "VOID")
										{
											/* error return mismatch*/
											output::errorMismatch(yylineno);
											exit(1);
										}
									}
			| IF LPAREN BoolExp RPAREN NEWSCOPE Statement ENDSCOPE %prec IF {
				buffer.bpatch($3.truelist, $6.label);
				$$.nextlist = $6.nextlist;
				$$.nextlist.merge($3.falselist); // TODO : implement, this is pseudo-code
			}
			| IF LPAREN BoolExp RPAREN NEWSCOPE Statement ENDSCOPE ELSE {manager.newScope("else");}Statement {
			    manager.popScope();
			    buffer.bpatch($3.truelist, $6.label);
				$$.nextlist = $6.nextlist;
			    buffer.bpatch($3.truelist, $6.label);
			    buffer.bpatch($3.falselist, $10.label);
			    $$.nextlist.merge($10.nextlist); // TODO : implement, this is pseudo-code

			}
			| WHILE LPAREN BoolExp RPAREN {manager.newScope("while");} Statement {
			    manager.popScope();
			    buffer.bpatch($3.truelist, $6.label);
			    $$.nextlist = $6.nextlist;
			    $$.nextlist.merge($3.falselist); // TODO : implement, this is pseudo-code
			    emit("br label %"+ $3.label); // TODO : not sure about this one
			}
			| BREAK SC  	{ 
								if (!manager.inScope("while"))
								{
								    output::errorUnexpectedBreak(yylineno);
									exit(1);
								}
							}
			| CONTINUE SC   {
								if (!manager.inScope("while"))
								{
									output::errorUnexpectedContinue(yylineno);
									exit(1);
								}
							}
;
Call 		: FuncID LPAREN 	{
												FuncClass* func = dynamic_cast<FuncClass*>(manager.get($1));
											
												if (func == nullptr)
												{
													output::errorUndef(yylineno, $1);
													exit(1);
												}
								}   ExpList RPAREN	{
												FuncClass* func = dynamic_cast<FuncClass*>(manager.get($1));
											
												if (func == nullptr)
												{
													output::errorUndefFunc(yylineno, $1);
													exit(1);
												}
												if (!func->legalParams($4.list)){
													std::vector<std::string> types;
													for (TYPEClass y: func->params)
													{
														types.push_back(y.type);
													}
													
													output::errorPrototypeMismatch(yylineno, func->name, types);
													exit(1);
												}
												$$.type = func->ret_type;
												
								}
	 		| FuncID LPAREN RPAREN				{
												FuncClass* func = dynamic_cast<FuncClass*>(manager.get($1));
												if (func == nullptr)
												{
													output::errorUndefFunc(yylineno, $1);
													exit(1);
												}
												if (!func->params.empty())
												{
													std::vector<std::string> types;
													for (TYPEClass y: func->params)
													{
														types.push_back(y.type);
													}
													
													output::errorPrototypeMismatch(yylineno, func->name, types);
													exit(1);
												}
												$$.type = func->ret_type;
											}
;
FuncID 		: ID {$$ = yylval.id;};
ExpList 	: Exp	{ $$.list.push_back($1);}
			| Exp COMMA ExpList		{$$.list.push_back($1); $$.list.insert( $$.list.end(), $3.list.begin(), $3.list.end() );}
;
Type 		: INT	{ $$.type = "INT";}
			| BYTE	{ $$.type = "BYTE";}
			| BOOL	{ $$.type = "BOOL";}

;
Exp 		: LPAREN Exp RPAREN	{$$.type = $2.type;}                  /*TYPES HAVE TO BE CAPITILIZED LIKE RULES GIVEN IN HW3 PDF*/
			| Exp IF LPAREN Exp RPAREN ELSE Exp {
													checkBoolean($4);
													if (isNumeral($1) && isNumeral($7))
													{
														$$.type = largestType($1.type, $7.type);
													}
													else if ($1.type != $7.type)
													{
														output::errorMismatch(yylineno);
														exit(1);
													}
													else
													{
														$$.type = $1.type;
													}
												}
			| Exp ADD Exp 				{
											checkNumeral($1);
											checkNumeral($3);

											$$.type = largestType($1.type, $3.type);
											$$.reg = freshVar();
											buffer.emit($$.reg + " = add " + getLargestType($1.type,$3.type) + " " + $1.reg + ", " + $3.reg);
										}
			| Exp SUB Exp				{
											checkNumeral($1);
											checkNumeral($3);

											$$.type = largestType($1.type, $3.type);
											$$.reg = freshVar();
											buffer.emit($$.reg + " = sub " + getLargestType($1.type,$3.type) + " " + $1.reg + ", " + $3.reg);
										}
			| Exp DIV Exp				{
											checkNumeral($1);
											checkNumeral($3);
											$$.type = largestType($1.type, $3.type);
											$$.reg = freshVar();
											std::string type = $$.type == "INT" ? "sdiv" : "udiv";
											buffer.emit($$.reg + " = " + type + " " + getLargestType($1.type,$3.type) + " " + $1.reg + ", " + $3.reg);
			
										}
			
			| Exp MULT Exp				{	
											checkNumeral($1);
											checkNumeral($3);
											$$.reg = freshVar();
											buffer.emit($$.reg + " = mul " + getLargestType($1.type,$3.type) + " " + $1.reg + ", " + $3.reg);
										}
			| ID 						{
											TYPEClass* y = manager.get(yylval.id);
											//cout << "ashe's id is " << yylval.id << endl;
											//cout << "saved name is " << y->name << endl;
											if (y == nullptr)
											{
												output::errorUndef(yylineno, yylval.id);
												exit(1);
											}
											if (dynamic_cast<FuncClass*>(y) != nullptr)
											{
												output::errorUndef(yylineno, yylval.id);
												exit(1);
											}
											/*
											this one is a bit different -
										    what we need here is:
										    1 - $$.reg = freshVar()
										    2 - emit(load i32 (not sure about i32 here), ptr y->ptr;
											*/
											$$.reg = y->reg;
											$$.type = y->type;

										}
			| Call						{$$.type = $1.type; }
			| NUM						{$$.type = "INT"; $$.reg = std::to_string(yylval.byte);}
			| NUM B 					{$$.type = "BYTE"; checkByte(yylval.byte); $$.reg = std::to_string(yylval.byte);}
			| STRING					{$$.type = "STRING"; $$.reg = "";}
			| TRUE						{
											$$.type = "BOOL";
											$$.reg = "true";
											$$.label = freshLabel("true");
											buffer.emit($$.label + ":");
											int location = buffer.emit("br label @");
											$$.truelist.push_back(std::pair<int, BranchLabelIndex>(location, FIRST));
											
										}
			| FALSE						{
											$$.type = "BOOL";
											$$.reg = "false";
											$$.label = freshLabel("false");
											buffer.emit($$.label + ":");
											int location = buffer.emit("br label @");
											$$.falselist.push_back(std::pair<int, BranchLabelIndex>(location, FIRST));

										}
			| NOT Exp					{
											checkBoolean($2);
											$$.type = "BOOL";

											$$.truelist = $2.falselist;
											$$.falselist = $2.truelist;
										}
			| Exp AND Exp				{
											checkBoolean($1);
											checkBoolean($3);
											$$.type = std::string("BOOL");
							


											buffer.bpatch($1.truelist, $3.label);
											$$.falselist = $1.falselist;
											
											$$.falselist.insert($$.falselist.end(), $3.falselist.begin(), $3.falselist.end());
											$$.truelist = $3.truelist;

										}
			| Exp OR Exp				{
											checkBoolean($1);
											checkBoolean($3);
											$$.type = std::string("BOOL");

											$$.truelist = $1.truelist;
											$$.truelist.insert($$.truelist.end(), $3.truelist.begin(), $3.truelist.end()); // 
											/* SOLVE THIS PROBLEM - TRUELIST IS EMPTY ???? */
											for (int i = 0; i < $$.truelist.size(); i++){
												cout << $$.truelist[i].first << endl;
											}
											
											buffer.bpatch($1.falselist, $3.label); 
											$$.falselist = $3.falselist;
										}
			| Exp RELOP Exp				{
											
											checkNumeral($1);
											checkNumeral($3);
											$$.type = std::string("BOOL");

											$$.label = freshLabel("relop");
											buffer.emit($$.label + ":");
											$$.reg = freshVar();
											buffer.emit($$.reg + " = icmp " + processRelop(yylval.relop) + " i32 " + $1.reg + ", " + $3.reg);
											int location = buffer.emit("br i1 " + $$.reg + ", label @, label @");
											$$.truelist.push_back(std::pair<int, BranchLabelIndex>(location, FIRST));
											$$.falselist.push_back(std::pair<int, BranchLabelIndex>(location, SECOND));

											
											
										}
			| LPAREN Type RPAREN Exp	{
											checkNumeral($4);
											checkNumeral($2);
											$$.type = std::string($2.type);
										}
;

%%
int main()
{
	int res = yyparse();
	manager.checkMain();
	///*output::endScope*/();
	manager.popScope();
	buffer.printGlobalBuffer();
	buffer.printCodeBuffer();
	return res;
}

int yyerror(const char * message)
{
	output::errorSyn(yylineno);
	exit(1);
}
